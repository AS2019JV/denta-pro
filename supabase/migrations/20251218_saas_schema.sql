-- 1. Enable Encryption Extension
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- 2. Update Roles ENUM/Check
ALTER TABLE public.profiles 
DROP CONSTRAINT IF EXISTS profiles_role_check;

ALTER TABLE public.profiles 
ADD CONSTRAINT profiles_role_check 
CHECK (role IN ('clinic_owner', 'doctor', 'receptionist'));

-- 3. Add Soft Delete & Clinic Isolation to Core Tables
ALTER TABLE public.patients ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMP WITH TIME ZONE;
ALTER TABLE public.appointments ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMP WITH TIME ZONE;
ALTER TABLE public.billings ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMP WITH TIME ZONE;
ALTER TABLE public.profiles ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMP WITH TIME ZONE;
ALTER TABLE public.hcu033_forms ADD COLUMN IF NOT EXISTS deleted_at TIMESTAMP WITH TIME ZONE;

-- 4. Create Clinical Records (High Sensitivity)
CREATE TABLE IF NOT EXISTS public.clinical_records (
    id uuid DEFAULT uuid_generate_v4() PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    clinic_id uuid REFERENCES public.clinics(id) NOT NULL,
    patient_id uuid REFERENCES public.patients(id) NOT NULL,
    doctor_id uuid REFERENCES public.profiles(id),
    diagnosis bytea, -- Encrypted content
    treatment_plan text,
    xray_urls text[],
    notes text,
    deleted_at TIMESTAMP WITH TIME ZONE
);

ALTER TABLE public.clinical_records ENABLE ROW LEVEL SECURITY;

-- 5. Create Audit Logging Schema
CREATE SCHEMA IF NOT EXISTS logs;

CREATE TABLE IF NOT EXISTS logs.access_audit (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    timestamp TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    actor_id uuid, -- Who did it
    actor_role text,
    action text NOT NULL, -- 'SELECT', 'INSERT', 'UPDATE'
    table_name text NOT NULL,
    record_id uuid,
    clinic_id uuid,
    metadata jsonb
);

ALTER TABLE logs.access_audit ENABLE ROW LEVEL SECURITY;

-- 6. Create Secure View for Receptionists
-- Drop if exists to ensure clean slate
DROP VIEW IF EXISTS public.receptionist_patient_view;

CREATE VIEW public.receptionist_patient_view AS
SELECT 
    id, 
    clinic_id, 
    first_name, 
    last_name, 
    phone, 
    email, 
    created_at 
FROM public.patients
WHERE deleted_at IS NULL;

-- 7. RLS POLICIES (Using JWT Claims)

-- A. Profiles: Users read their own profile OR profiles in their clinic
DROP POLICY IF EXISTS "Users can view profiles in their clinic" ON public.profiles;
CREATE POLICY "Users can view profiles in their clinic"
ON public.profiles FOR SELECT
USING (
    id = auth.uid() OR
    clinic_id = (auth.jwt() -> 'app_metadata' ->> 'clinic_id')::uuid
);

-- B. Clinical Records: STRICT (Owner & Doctor Only)
CREATE POLICY "Medical staff can view clinical records"
ON public.clinical_records
FOR ALL
USING (
    clinic_id = (auth.jwt() -> 'app_metadata' ->> 'clinic_id')::uuid
    AND
    (auth.jwt() -> 'app_metadata' ->> 'role') IN ('clinic_owner', 'doctor')
);

-- C. Financials (Billings): STRICT (Owner Only - maybe doctor?)
-- Current requirement: Owner only? Or Admins? 
-- Let's stick to Owner + Doctor can see basic billing, maybe restrict sensitive?
-- Plan said: "Receptionist NO ACCESS". Doctors usually need to know if paid?
-- Re-reading plan: "Doctor: NO ACCESS to financials". OK. Owner Only.
DROP POLICY IF EXISTS "Users can view billings in their clinic" ON public.billings;
CREATE POLICY "Owners can view billings"
ON public.billings
FOR ALL
USING (
    clinic_id = (auth.jwt() -> 'app_metadata' ->> 'clinic_id')::uuid
    AND
    (auth.jwt() -> 'app_metadata' ->> 'role') = 'clinic_owner'
);

-- D. Reception View Permissions
-- Revoke direct access to patients for receptionist (Handled via Role Management in Supabase, 
-- but RLS is the fallback). 
-- actually RLS on 'patients' must allow access for the View to work for the owner of the view, 
-- BUT we can enforce it via the View's permissions if we use SECURITY DEFINER or careful Grants.
-- Simplest RLS for Patients:
DROP POLICY IF EXISTS "Users can view patients in their clinic" ON public.patients;
CREATE POLICY "Users can view patients in their clinic"
ON public.patients FOR SELECT
USING (
    clinic_id = (auth.jwt() -> 'app_metadata' ->> 'clinic_id')::uuid
);
-- Note: Receptions CAN TECHNICALLY select * from patients if they hit the API directly 
-- UNLESS we restrict columns or use Field Selection Security (not native to Supabase yet).
-- The Plan suggested: "Revoke ALL on public.patients FROM authenticated" + "Grant SELECT on view".
-- This works at the Table Permission level.

REVOKE ALL ON public.patients FROM authenticated;
GRANT SELECT ON public.receptionist_patient_view TO authenticated;
-- We need to re-grant permissions to specific roles if using Postgres Roles, 
-- but Supabase uses 'authenticated' role for everyone. 
-- So we actually need to Grant SELECT on patients to authenticated 
-- BUT relying on the Filter to hide rows? No, we want to hide COLUMNS.
-- PostgREST allows Column Privileges.
-- GRANT SELECT (id, clinic_id, first_name) ON public.patients TO authenticated;
-- But that breaks 'select *'.
-- For now, we will trust the View strategy:
-- The Frontend must use the View for receptionists.
-- Backend RLS allows access to the Row, so technically a hacking Receptionist could fetch medical_history 
-- IF they know the endpoint.
-- To strictly prevent this, we would need separate Postgres Roles for 'doctor' vs 'receptionist', 
-- mapping Supabase Auth Roles to Postgres Roles. 
-- For this iter, we stick to the Plan's "Secure View" and will add Column-Level RLS if strictness is P0.

-- 8. Audit Log Policies
CREATE POLICY "No one allows update on audit"
ON logs.access_audit
FOR UPDATE
USING (false);

CREATE POLICY "No one allows delete on audit"
ON logs.access_audit
FOR DELETE
USING (false);

CREATE POLICY "System can insert audit"
ON logs.access_audit
FOR INSERT
WITH CHECK (true); -- Trigger will do this as postgres user?

